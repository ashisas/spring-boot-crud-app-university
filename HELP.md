# Spring Boot CRUD App

## Annotations:

- `@EnableAutoConfiguration`: Used to initialize default configurations such as the dispatcher servlet, creating the embedded Tomcat server, and scanning the classpath to load child dependencies.

- `@Configuration`: Class-level annotation indicating the class contains one or more `@Bean` definition methods.

- `@ComponentScan`: Used to instantiate objects at startup in the application context. Objects added to the context are referred to as Spring beans.

- `@RestController`: A combination of `@Controller` and `@ResponseBody`. `@Controller` is used to define a class as a Spring MVC controller, while `@ResponseBody` is used to bind the returned object to the HTTP response body. By using `@RestController`, both `@Controller` and `@ResponseBody` annotations are eliminated.

- `@RequestMapping`: Defines the root path for the controller.

- `@PostMapping`: Used when creating a new resource.

- `@PutMapping`: Used when updating an existing resource.

- `@DeleteMapping`: Used when deleting a record based on an ID.

- `@GetMapping`: Used when fetching/retrieving resources/data from the server.

- `@PatchMapping`: Used when updating specific fields instead of the whole resource/record.

- `@DeleteMapping`: Used when deleting records.

- `ResponseEntity`: Used to add additional details to the response, such as custom status code and headers.

- `@PathVariable`: Binds the value from the URI path variable "universityId" to the method parameter.

- `@Service`: Used to annotate classes that provide business services, perform business logic, or act as a service layer in a Spring application. Automatically registered as Spring beans during component scanning.

- `@Entity`: Maps to a table in an RDBMS.

- `@Table`: Specifies the table name and schema.

- `@Id`: Defines a primary key for the entity.

- `@Column`: Customizes column details in a table, such as column size and name.

# Database Configuration for PostgreSQL in Spring Boot

```properties
# This line specifies the JDBC URL for connecting to the PostgreSQL database.
# It follows the format jdbc:postgresql://<host>:<port>/<database>
# In this case:
# - jdbc:postgresql://: Indicates the JDBC connection for PostgreSQL.
# - localhost: The hostname where your PostgreSQL database is running.
# - 5432: The port number on which PostgreSQL is listening.
# - university: The name of the database.
spring.datasource.url=jdbc:postgresql://localhost:5432/university

# Specifies the username used to authenticate against the PostgreSQL database.
# In this case, the username is set to postgres.
spring.datasource.username=postgres

# Specifies the password used to authenticate to the user specified in spring.datasource.username.
# The password is set to root.
spring.datasource.password=root

# This property enables displaying SQL statements generated by Hibernate in the console.
spring.jpa.show-sql=true

# Specifies Hibernate's dialect for PostgreSQL.
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect

# This property is used for Hibernate's schema generation.
spring.jpa.hibernate.ddl-auto = update

# Create University - HTTP Request

Execute the following APIs:
## Health check API:
**Endpoint:** `http://localhost:8080/api/status`

## Create University:

**Endpoint:** `http://localhost:8080/api/university/v1/create`

**Request:**
```json
{
    "universityId": "UNI-3",
    "universityName": "SAMPLE-UNIVERSITY",
    "address": "SAMPLE",
    "createdBy": "SAMPLE"
}

## get all University:

**Endpoint:** `http://localhost:8080/api/university/v1/all`


## update  University:

**Endpoint:** `http://localhost:8080/api/university/v1/update`
**Request:**
```json
{
      "universityId": "UNI-35",
      "address": "SAMPLE-UPDATED-ADDRESS"
}

## delete  University:

**Endpoint:** `http://localhost:8080/api/university/v1/delete/{universityid}`
 
